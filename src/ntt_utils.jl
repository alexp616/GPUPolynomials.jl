using CUDA
using Test
using Primes
using BenchmarkTools
using Dates

import Base.div


# Also exists to guarantee positive mod numbers so my chinese remainder theorem
# doesn't get messed up
"""
    faster_mod(x::Int, m::Int)::Int

Not actually faster, but ensures result is positive.
"""
@inline function faster_mod(x::T, m::Integer)::T where T<:Integer
    m = T(m)
    r = x - div(x, m) * m
    return r < 0 ? r + m : r
end

"""
    div(n::Int128, m::Int128)::Int128

div function for Int128's that can be called inside CUDA kernels, since Base.div can't
"""
function div(n::Int128, m::Int128)::Int128
    if n == 0
        return Int128(0)
    end

    sign = 1
    if (n < 0) != (m < 0)
        sign = -1
    end

    n = abs(n)
    m = abs(m)

    quotient = Int128(0)
    remainder = Int128(0)

    for i in 0:127
        remainder = (remainder << 1) | ((n >> (127 - i)) & 1)
        if remainder >= m
            remainder -= m
            quotient |= (Int128(1) << (127 - i))
        end
    end

    return quotient * sign
end


function extended_gcd_iterative(a::T, b::T) where T<:Integer
    x0, x1 = T(1), T(0)
    y0, y1 = T(0), T(1)
    while b != 0
        q, r = divrem(a, b)
        a, b = b, r
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    end
    @assert a == 1 "$a and $b aren't coprime"
    return x0, y0
end

function pregen_crt(primeArray::Vector{Int}, crtType::DataType)
    result = zeros(crtType, 3, length(primeArray) - 1)
    currmod = primeArray[1]
    # Iterate through, compute m1 and m2 for each modulus
    # store n1 * m1 and n2 * m2, since CRT is a1 * n1 * m1 + a1 * n2 * m2
    for i in 2:length(primeArray)
        m1, m2 = extended_gcd_iterative(currmod, primeArray[i])
        # no point in reducing these mod n1n2 because m1 is bounded by n2, so n1m1 is bounded above by n1n2
        result[1, i - 1] = m1 * currmod
        result[2, i - 1] = m2 * primeArray[i]
        currmod *= primeArray[i]
        result[3, i - 1] = currmod
    end

    return CuArray(result)
end


"""
    chinese_remainder_two(a, n, b, m)

Return the smallest number `x` that satisfies `x = a mod n` and `x = b mod m`. Assumes
n and m are coprime.

In the return statement, the n0 and m0 represent the initial values of n and m, and 
y0 and x0 satisfy n0 * x0 + m0 * y0 = 1
"""
function chinese_remainder_two(a::T, n::T, b::Integer, m::Integer) where T<:Integer
    b = T(b)
    m = T(m)

    n0, m0 = n, m
    x0, x1 = T(1), T(0)
    y0, y1 = T(0), T(1)
    while m != 0
        q = div(n, m)
        n, m = m, faster_mod(n, m)
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    end

    return faster_mod(a * m0 * y0 + b * n0 * x0, T(n0 * m0))

end


"""
    find_ntt_primes(n)

Find primes of form k * n + 1 for 5 seconds
isprime() method is probabilistic, actually test for primality using
another method when using a prime from here
"""
function find_ntt_primes(n)
    start_time = now()
    prime_list = []
    k = 1

    while (now() - start_time) < Second(5)
        candidate = k * n + 1
        if isprime(candidate)
            push!(prime_list, candidate)
        end
        k += 1
    end

    return prime_list
end

"""
    get_ntt_length(numVars, prime)

Generate resulting ntt lengths for both steps after inputting numVars and prime
"""
function get_ntt_length(numVars, prime)
    step1HomogeneousDegree = numVars * (prime - 1)
    step1Length = nextpow(2, (step1HomogeneousDegree) * (step1HomogeneousDegree + 1) ^ (numVars - 2))
    step2HomogeneousDegree = step1HomogeneousDegree * prime 
    step2Length = nextpow(2, (step2HomogeneousDegree) * (step2HomogeneousDegree + 1) ^ (numVars - 2))
    return step1Length, step2Length
end

"""
    npruarray_generator(primearray, n)

Return array, where each corresponding value is the `n`th principal root of unity for the field generated by each prime
"""
function npruarray_generator(primearray::Array{T}, n::T) where T<:Integer
    return map(p -> nth_principal_root_of_unity(n, p), primearray)
end

"""
    inverse_generator(npruarray, n)

Return array, where each corresponding value is modular inverse of each corresponding npru in the field generated by each prime
"""
function inverse_generator(npruarray::Array, primearray::Array)
    @assert length(npruarray) == length(primearray)
    return mod_inverse.(npruarray, primearray)
end


"""
    power_mod(n, p, m)

Return n ^ p mod m. Only gives accurate results when
m is prime, since uses Fermat's Little Theorem
"""
function power_mod(n::T, p::Integer, m::Integer) where T<:Integer
    result = 1
    p = faster_mod(p, m - 1)
    base = faster_mod(n, m)

    while p > 0
        if p & 1 == 1
            result = faster_mod((result * base), m)
        end
        base = faster_mod(base * base, m)
        p = p >> 1
    end

    return result
end


"""
    mod_inverse(n, p)

Return n^-1 mod p. Assumes n is actually invertible mod p
"""
function mod_inverse(n::Integer, p::Integer)
    n = faster_mod(n, p)

    t, new_t = 0, 1
    r, new_r = p, n

    while new_r != 0
        quotient = r รท new_r
        t, new_t = new_t, t - quotient * new_t
        r, new_r = new_r, r - quotient * new_r
    end

    return t < 0 ? t + p : t
end

"""
    nth_principal_root_of_unity(n, p)

Computes an n-th principal root of unity mod p
"""
function nth_principal_root_of_unity(n::Integer, p::Integer)
    @assert faster_mod(p - 1, n) == 0 "n must divide p-1"

    order = (p - 1) รท n

    function is_primitive_root(g, p, order)
        for i in 1:(n-1)
            if power_mod(g, i * order, p) == 1
                return false
            end
        end
        return true
    end
    
    g = 2
    while !is_primitive_root(g, p, order)
        g += 1
    end

    root_of_unity = power_mod(g, order, p)
    return typeof(n)(root_of_unity)
end

"""
    parallel_bit_reverse_copy(p)

Butterflies indices of p
"""
function parallel_bit_reverse_copy(p)
    @assert ispow2(length(p)) "p must be an array with length of a power of 2"
    len = length(p)
    result = CUDA.zeros(eltype(p), len)
    log2n = Int(log2(len))

    function kernel(p, dest, len, log2n)
        idx1 = threadIdx().x + (blockIdx().x - 1) * blockDim().x - 1
        idx2 = idx1 + Int(len / 2)
    
        rev1 = bit_reverse(idx1, log2n)
        rev2 = bit_reverse(idx2, log2n)
    
        dest[idx1 + 1] = p[rev1 + 1]
        dest[idx2 + 1] = p[rev2 + 1]
        return nothing
    end

    kernel = @cuda launch = false kernel(p, result, len, log2n)
    config = launch_configuration(kernel.fun)
    threads = min(len รท 2, prevpow(2, config.threads))
    blocks = cld(len รท 2, threads)

    kernel(p, result, len, log2n; threads = threads, blocks = blocks)
    
    return result
end

"""
    bit_reverse(x, log2n)

Reverses the order of bits of `x`
"""
function bit_reverse(x::Integer, log2n::Integer)
    temp = 0
    for i in 0:log2n-1
        temp <<= 1
        temp |= (x & 1)
        x >>= 1
    end
    return temp
end

"""
    generate_butterfly_permutations(n)

Generates a permutation array for butterflying arrays of length `n`
"""
function generate_butterfly_permutations(n::Int)::CuVector{Int}
    @assert ispow2(n) "n must be a power of 2"
    perm = parallel_bit_reverse_copy(CuArray([i for i in 1:n]))
    return perm
end